## Project: Kinematics Pick & Place

[//]: # (Image References)

[image1]: ./misc_images/misc4.png
[image2]: ./misc_images/misc3.png
[image3]: ./misc_images/misc5.png

The Kuka-arm used in this project is a SCARA serial manipulator consisting of 6 revolute joints.

### Kinematic Analysis
The following orgins locations and axes orientations were used for the project.

![alt text][image1]

The DH parameter table was populated based on the image above. The actual measurements were taken from the serial manipulator's URDF file.

Links | alpha(i-1) | a(i-1) | d(i-1) | theta(i)
--- | --- | --- | --- | ---
0->1 | 0 | 0 | 0.75 | q1
1->2 | - pi/2 | 0.35 | 0 | -pi/2 + q2
2->3 | 0 | 1.25 | 0 | q3
3->4 |  - pi/2 | -0.054 | 1.5 | q4
4->5 | pi/2 | 0 | 0 | q5
5->6 | - pi/2 | 0 | 0 | q6
6->7 | 0 | 0 | 0.303 | 0

A Transformation Maxtrix symbolic form was then made using the variables from the DH paramter table.

         TF_Matrix ([[cos(q), -sin(q), 0, a],
                   [sin(q) * cos(alpha), cos(q) * cos(alpha), -sin(alpha), -sin(alpha) * d],
                   [sin(q) * sin(alpha), cos(q) * sin(alpha), cos(alpha), cos(alpha) * d],
                   [0, 0, 0, 1]])
                   
Indivitual transformation matricies for each joint-to-joint transformation were generated by subsituting the relavent values from the DH parameter table.

    T0_1 = TF_Matrix(a0,alpha0,d1,q1).subs(dh_params)
    T1_2 = TF_Matrix(a1,alpha1,d2,q2).subs(dh_params)
    T2_3 = TF_Matrix(a2,alpha2,d3,q3).subs(dh_params)
    T3_4 = TF_Matrix(a3,alpha3,d4,q4).subs(dh_params)
    T4_5 = TF_Matrix(a4,alpha4,d5,q5).subs(dh_params)
    T5_6 = TF_Matrix(a5,alpha5,d6,q6).subs(dh_params)
    T6_7 = TF_Matrix(a6,alpha6,d7,q7).subs(dh_params)

To get the total transformation from T0 to the gripper joint (T7) the following equation was used.

   T0_7 =  T0_1 * T1_2 * T2_3 * T3_4 * T4_5 * T5_6 * T6_7


Becuase there is a discripency between the URDF file axes and the ones above the following rotatonal transformations were used to compensate for that difference at the Gripper (T7) were r, p, y are row, pitch and yaw respectively.


        ROT_x = Matrix([[1, 0, 0],
            [0, cos(r), -sin(r)],
            [0, sin(r), cos(r)]])

        ROT_y = Matrix([[cos(p), 0, sin(p)],
           		 [0, 1, 0],
           	       [-sin(p), 0, cos(p)]])

        ROT_z = Matrix([[cos(y), -sin(y), 0],
         	   [sin(y), cos(y), 0],
         	   [0, 0, 1]])

        ROT_GRIP = ROT_z * ROT_y * ROT_x
        
        ROT_URDFtoGRIP = ROT_z.subs(y, radians(180)) * ROT_y.subs(p, radians(-90))

        ROT_GRIP = ROT_GRIP * ROT_URDFtoGRIP

The gripper center (WC) was then calulated (symbolically) from the gripper position and offset using the equation below.

        POS_GRIP = Matrix([[px],
            		[py],
           		 [pz]])

	GRIP_OFFSET = 0.303

        WC = POS_GRIP - (GRIP_OFFSET) * ROT_GRIP[:,2]
        
After that the theta angles (called q above) were calulated for each joint.

For theta1 the following equation was used.

theta1 = atan2(WC[1],WC[0])

For theta2 and theta3 some triganomitry was used as shown in the figure below.

![alt text][image2]

Since sides a, b, c of the triagle are known values angles a, b, c were obtained using the SSS trangle rules. Theta3 was then found using the right triangle rules followed by the complement property and Theta 4 was found using the complement property

        #triangle for theta2 and theta3
        side_a = 1.501
        side_b = sqrt(pow((sqrt(WC[0]*WC[0] + WC[1]*WC[1]) - 0.35), 2) + pow((WC[2] - 0.75), 2))
        side_c = 1.25

        angle_a = acos((side_b * side_b + side_c * side_c - side_a * side_a) / (2 * side_b * 	   side_c))
        angle_b = acos((side_a * side_a + side_c * side_c - side_b * side_b) / (2 * side_a * side_c))
        angle_c = acos((side_a * side_a + side_b * side_b - side_c * side_c) / (2 * side_a * side_b))
        
        theta2 = pi / 2 - angle_a - atan2(WC[2] - 0.75, sqrt(WC[0] * WC[0] + WC[1]) - 0.35)
        theta3 = pi / 2 - (angle_b + 0.036)
        
To find theta4, 5 and 6, first a rotation matrix of these joints (4, 5 and 6 ) was calulated and then the Euler angles (theta4, 5 ,6) were obtained from the rotation matrix.

	#Rotation matrix for joints 4,5,6
        R0_3 = T0_1[0:3,0:3] * T1_2[0:3,0:3] * T2_3[0:3,0:3]
        R0_3 = R0_3.evalf(subs={q1: theta1, q2: theta2, q3: theta3})

        R3_6 = R0_3.inv("LU") * ROT_GRIP

        #Euler angles from rotation matrix
        theta4 = atan2(R3_6[2,2], -R3_6[0,2])
        theta5 = atan2(sqrt(R3_6[0,2]*R3_6[0,2] + R3_6[2,2]*R3_6[2,2]),R3_6[1,2])
        theta6 = atan2(-R3_6[1,1], R3_6[1,0])



### Project Implementation
After all the Forward and Reverse Kinematics calulations were done and coded into the IK_server.py script. The project was ready for tested and it performed as desired. Given the position of a target and of a final placement position the serial manipulator was able to grip the target and move it to its specified final position.

![alt text][image3]
